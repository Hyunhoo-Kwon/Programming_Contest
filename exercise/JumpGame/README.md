#문제: 외발 뛰기(JumpGame)
- N*M 크기의 격자에 1부터 9까지의 정수를 쓴 게임이 있다. 이때 게임의 목적은 게임판의 왼쪽 위 칸에서 시작해서 게임판의 맨 으론쪽 아래 칸 0에 도착하는 것이다. 이때 각 칸에 적혀 있는 숫자만큼 아래쪽이나 오른쪽으로 이동할 수 있으며, 중간에 게임판 밖으로 벗어나면 안 된다.
- 게임판이 주어질 때 시작점에서 끝점 0으로 도달하는 방법이 존재하는지 확인하는 프로그램을 작성하시오.

###입력
- 파일의 첫째 줄에는 테스트 케이스 개수를 나타내는 자연수 T가 주어지고,
- 이후 차례로 T개의 테스트 케이스가 주어진다.
- 각각의 테스트 케이스 첫 번째 줄에는 게임판의 크기 N, M이 주어진다. (1<=N, M<=20)
- 다음 줄부터는 N개의 줄이 주어지고, 각 줄마다 M개의 문자가 주어진다, 각 문자는 0~9 중 하나이다.
- 문자 '0'은 끝점을 의미한다.

###출력
- 각 테스트 케이스의 답을 순서대로 표준출력으로 출력하여야 하며,
- 각 테스트 케이스마다 철 줄에 "Case #T"를 출력하여야 한다. 이때 T는 테스트 케이스의 번호이다.
- 그 다음 줄에는 끝점으로 도달하는 방법이 존재하는 경우 "True", 방법이 존재하지 않는 경우 "False"를 출력한다.

###입력 예
- 2
- 7 7
- 2 5 1 6 1 4 1
- 6 1 1 2 2 9 3
- 7 2 3 2 1 3 1
- 1 1 3 1 7 1 2
- 4 1 2 3 4 1 2
- 3 3 1 2 3 4 1
- 1 5 2 9 4 7 0
- 7 7
- 2 5 1 6 1 4 1
- 6 1 1 2 2 9 3
- 7 2 3 2 1 3 1
- 1 1 3 1 7 1 2
- 4 1 2 3 4 1 3
- 3 3 1 2 3 4 1
- 1 5 2 9 4 7 0

###출력 예
Case #1
True
Case #2
False

##풀이
###기본 풀이
- 동적 계획법을 이용해 최적화 문제를 해결한다.
- 우선 맨 왼쪽 윗칸에서 시작하는 모든 경로를 하나씩 만들어 보며 마지막 칸에 도달할 수 있는지 검사하는 완전 탐색 알고리즘을 만든다.
- 재귀 함수는 다음과 같이 만든다.
- jump(y, x)는 (y, x)에서부터 맨 마지막 칸까지 도달할 수 있는지 여부를 반환한다.
- jump(y, x)는 한번 호출될 때마다 여기에서 아래쪽으로 뛸지, 오른쪽으로 뛸지를 선택한다. 게임판의 (y,x) 위치에 있는 수를 jumpSize라 하면, 각 경우 아래쪽으로 뛸 경우 마지막 칸에 도달할 수 있는지를 jump(y+jumpSize, x), 으론쪽으로 뛸 경우 jump(y, x+jumpSize)로 표현할 수 있다. 이 두 경우 중 하나만 성공해도 상관없으니 jump(y, x)는 다음과 같이 재귀적으로 표현할 수 있다.
- jump(y, x) = jump(y+jumpSize, x) || jump(y, x+jumpSize)
- 위와 같은 완전 탐색에 메모이제이션을 적용한다.

###동적 계획법 레시피
- 대개 동적 계획법 알고리즘의 구현은 다음과 같이 두 단계로 이루어진다.
- 1. 주어진 문제를 완전 탐색을 이용해 해결한다.
- 2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.

##구현
- inputData()는 입력 값을 읽어오고, printResult()는 결과를 출력한다.
- initialize_cache()는 메모이제이션에 사용되는 cache를 초기화한다.
- 메모이제이션의 적용의 편의를 위해 jump()는 boolean이 아닌 int로 구현한다.
- jump(y, x)는 게임판을 벗어난 경우 0, 마지막 칸에 도착한 경우 1을 반환하고, 그 외의 경우 아래쪽으로 뛸 경우와 오른쪽으로 뛸 경우를 각각 시도한다.