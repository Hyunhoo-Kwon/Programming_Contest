#문제: 게임판 덮기(BoardCover)
- N*M 크기의 게임판이 있다. 게임판은 흰 칸과 검은 칸으로 구성된 격자 모양을 하고 있는데 이 중 모든 흰 칸을 세 칸짜리 L자 모양의 블록으로 덮으려 한다. 이때 블록들은 자유롭게 회전해서 놓을 수 있지만, 서로 겹치거나, 검은 칸을 덮거나, 게임판 밖으로 나가서는 안 된다.
- 게임판이 주어질 때 이를 덮는 방법의 수를 계산하는 프로그램을 작성하시오.

###입력
- 파일의 첫째 줄에는 테스트 케이스 개수를 나타내는 자연수 T가 주어지고,
- 이후 차례로 T개의 테스트 케이스가 주어진다.
- 각각의 테스트 케이스 첫 번째 줄에는 게임판의 크기 N, M이 주어진다. (1<=N, M<=20)
- 다음 줄부터는 N개의 줄이 주어지고, 각 줄마다 M개의 문자가 주어진다, 각 문자는 {'0', '1'}에 속하는 문자 중 하나이다.
- 문자 '0'은 흰 칸, 문자 '1'은 검은 칸을 나타낸다. 입력에 주어지는 게임판에 있는 흰 칸의 수는 50을 넘지 않는다.

###출력
- 각 테스트 케이스의 답을 순서대로 표준출력으로 출력하여야 하며,
- 각 테스트 케이스마다 철 줄에 "Case #T"를 출력하여야 한다. 이때 T는 테스트 케이스의 번호이다.
- 그 다음 줄에는 흰 칸을 모두 덮는 방법의 수를 출력한다.

###입력 예
- 3
- 3 7
- 1 0 0 0 0 0 1
- 1 0 0 0 0 0 1
- 1 1 0 0 0 1 1
- 3 7
- 1 0 0 0 0 0 1
- 1 0 0 0 0 0 1
- 1 1 0 0 1 1 1
- 8 10
- 1 1 1 1 1 1 1 1 1 1
- 1 0 0 0 0 0 0 0 0 1
- 1 0 0 0 0 0 0 0 0 1
- 1 0 0 0 0 0 0 0 0 1
- 1 0 0 0 0 0 0 0 0 1
- 1 0 0 0 0 0 0 0 0 1
- 1 0 0 0 0 0 0 0 0 1
- 1 1 1 1 1 1 1 1 1 1

###출력 예
- Case #1
- 0
- Case #2
- 2
- Case #3
- 1514

##풀이
###기본 풀이
- 게임판을 덮을 수 있는 모든 경우를 생성하는 완전 탐색(exhaustive search)를 이용해 해결한다. 
- 입력으로 주어진 게임판에서 흰 칸의 수가 3의 배수가 아닐 경우에는 무조건 답이 없으니 따로 처리한다. 
- 재귀 함수는 주어진 게임판에 블록을 한개 내려놓고 남은 흰 칸들을 재귀 호출을 이용해 덮는다.

###중복으로 세는 문제
- 중복으로 세는 문제를 해결하기 위해 특정한 순서대로 답을 생성하도록 강제한다.
- 재귀 호출의 각 단계마다 아직 빈 칸 중에서 가장 윗 줄, 그 중에서도 가장 왼쪽에 있는 칸을 덮도록 한다. 이렇게 하면 답을 한 가지 방법으로밖에 생성할 수 없으므로 중복으로 세는 문제를 해결할 수 있다.
- 위의 가정에 따라 첫 번째 빈칸의 왼쪽과 위에 있는 칸은 항상 채워져 있다. 따라서 각 칸을 채우는 방법은 모두 네 가지 이다.
- 재귀 호출 알고리즘은 첫 번째 빈칸을 찾은 후 네 가지의 덮을 방법을 하나하나 시도한다. 이 방법이 달라질 때마다 서로 다른 배치가 되므로, 우리가 원하는 답은 남은 게임판을 재귀 호출에 넘겨서 얻은 경우의 수를 모두 더한 수가 된다.

##구현
- inputData()는 입력 값을 읽어오고, printResult()는 결과를 출력한다.
- solve()는 게임판에서 흰 칸의 수가 3의 배수일 경우 0, 그 외의 경우 cover()을 호출하여 결과 값을 반환한다.
- cover()는 모든 칸을 채웠을 경우 1, 그 외의 경우 첫 번째 빈칸을 찾아 게임판을 type 형태로 덮을 수 있을 경우 재귀 호출한다.
- 한 칸을 덮는 네 가지 방법은 coverType 배열에 저장한다. 이 배열은 네 가지 방법에서 새로 채워질 칸들의 상대 좌표(y, x)의 목록을 저장한다.
- set()은 delta에 따라 블록을 놓는 역할과 치우는 역할을 같이 할 수 있다.
- set()은 해당 위치에 블록을 놓을 수 있는지 여부도 같이 판단한다. 
- 단 이때 곧장 함수를 종료하는 것이 아니라 마지막까지 함수를 실행한다는 데 유의한다. 만약 블록을 구성하는 세 칸 중에 한 칸에 표시를 한 뒤 두 번째 칸에 이미 블록이 놓여 있다는 것을 발견했다고 가정 한다. 이때 함수를 곧장 종료하면 나중에 덮었던 블록을 치울 때, 두 번째 칸에 이미 있던 블록마저 치워 버리게 된다. 따라서 set()은 그 자리에 그냥 1을 더함으로써 이 칸에는 두 개의 블록이 겹쳐서 놓여 있다고 표시한다.
