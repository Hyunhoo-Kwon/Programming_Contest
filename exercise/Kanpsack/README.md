#문제: 배낭 문제(Knapsack Problem)
- 비행기 규정상 하나의 캐리어만 가지고 갈 수 있는데, 가져가고 싶은 물건들이 캐리어 안에 다 들어가지 않을 것 같다. 따라서 가져가고 싶은 각 물건들의 부피와 얼마나 필요한지를 나타내는 절박도를 조사해 다음과 같은 목록을 만들었다.
캐리어의 용량이 정해져 있기 때문에 가져갈 수 있는 물건들의 부피 합은 캐리어의 용량 w 이하여야 한다. 
- 이때 절박도를 최대화 할수 있는 물건들의 목록을 계산하는 프로그램을 작성하시오.

###입력
- 파일의 첫째 줄에는 테스트 케이스 개수를 나타내는 자연수 T가 주어지고,
- 이후 차례로 T개의 테스트 케이스가 주어진다. (1<=T<=50)
- 각각의 테스트 케이스 첫 번째 줄에는 가져가고 싶은 물건의 수 N과 캐리어의 용량 W가 주어진다. (1<=N<=100, 1<=W<=1000)
- 다음 N개의 줄에는 각 물건의 정보가 주어진다. 한 물건에 대한 정보는 물건의 이름, 부피, 절박도 순서대로 주어진다.

###출력
- 각 테스트 케이스의 답을 순서대로 표준출력으로 출력하여야 하며,
- 각 테스트 케이스마다 철 줄에 "Case #T"를 출력하여야 한다. 이때 T는 테스트 케이스의 번호이다.
- 그 다음 줄에는 각 물건들의 최대 절박도 합과 가져갈 물건들의 개수를 출력한다.
- 이후 한 줄에 하나씩 각 물건들의 이름을 출력한다.
- 만약 절박도를 최대화하는 물건들의 조합이 여럿일 경우 아무 것이나 출력해도 좋다.

###입력 예
- 2
- 6 10
- laptop 4 7
- camera 2 10
- xbox 6 6
- grinder 4 7
- dumbell 2 5
- encyclopedia 10 4
- 6 17
- laptop 4 7
- camera 2 10
- xbox 6 6
- grinder 4 7
- dumbell 2 5
- encyclopedia 10 4

###출력 예
- Case #1
- 24 3
- laptop
- camera
- grinder
- Case #2
- 30 7
- laptop
- camera
- grinder
- laptop
- camera
- xbox
- grinder

##풀이
###기본 풀이
- 동적 계획법을 이용해 최적화 문제를 해결한다.
- pack(capacity, item)은 캐리어의 용량이 capacity만큼 남았을 때 item 이후의 물건들을 싸서 얻을 수 있는 최대 절박도이다.
- 이때 각 물건에 대해 우리가 할 수 있는 선택은 가져간다/가져가지 않는다의 두 가지 이다. 각 경우의 최대 절박도는 다음과 같다.
- 해당 물건을 가져가는 경우: pack(capacity-volume[item], item+1) + need[item]
- 해당 물건을 가져가지 않는 경우: pack(capacity, item+1)
- volume[item]과 need[item]은 각각 해당 물건의 부피와 절박도를 의미한다.
- pack()은 두 선택지 중 항상 더 큰 답을 택하면 된다.

###답 추적하기
- 각 부분 문제에 선택지가 두 개밖에 없기 때문에 따로 선택을 저장하지 않고도 답을 역추적할 수 있다.
- pack(capacity, item) 부분 문제에서 item을 선택했는지를 알고 싶으면 pack(capacity, item+1)과 pack(capacity, item)이 같은지 비교하면 된다.
- 만약 두 값이 같다면 item을 선택하지 않고도 최대 절박도를 얻을 수 있다는 말이니 item을 무시하고, 아니면 목록에 item을 추가한다.

##구현
- inputData()는 입력 값을 읽어오고, printResult()는 결과를 출력한다.
- initialize_cache()는 메모이제이션에 사용되는 cache를 초기화한다.
- pack(capacity, item)은 캐리어의 용량이 capacity만큼 남았을 때 item 이후의 물건들을 싸서 얻을 수 있는 최대 절박도이다. 더 담을 물건이 없을 경우 0, 그 외의 경우 물건을 담지 않은 경우/물건을 담은 경우 중 더 큰 답을 택하여 반환한다. 
- pack(capacity, item)위와 같은 완전 탐색에 메모이제이션을 적용한 것이다.
- reconstruct(capacity, item)은 답을 역추적하여 선택한 물건들의 목록을 picked에 저장한다.